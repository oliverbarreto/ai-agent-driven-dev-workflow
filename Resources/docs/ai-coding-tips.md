Supercharge Your Vibe Coding in 21 Easy-to-Apply Tips
https://www.youtube.com/watch?v=RmcvVONkrWE&t=1072s

---

2655 visualizaciones  16 may 2025
 For the prompts discussed in the video, check out the free Skool group here: https://www.skool.com/tech-snack

In this video I break down my top 21 tips for Vibe Coding, really no matter the tool you use!

‚åöTimestamps:
00:00 Intro
02:00## Tip #1
02:56## Tip #2
04:55## Tip #3
06:53## Tip #4
08:12## Tip #5
09:23## Tip #6
10:48## Tip #7
12:11## Tip #8
13:23## Tip #9
14:40## Tip # 10
16:40## Tip #11
18:26## Tip #12
20:31## Tip #13
21:48## Tip #14
23:49## Tip #15
24:38## Tip #16
25:43## Tip #17
26:56## Tip #18
28:36## Tip #19
29:27## Tip #20
30:23## Tip #21

üóÑÔ∏è Resources:
https://cursor.directory/
   ‚Ä¢ Vibe Code Pro-Level UX/UI Without Des...  
   https://www.youtube.com/watch?v=VN-9utEicmw

   ‚Ä¢ 5 MCP Servers For Vibe Coding Glory (...  
   https://www.youtube.com/watch?v=LqTQi8qexJM

   ‚Ä¢ Vibe Code Like The Top 1% | Framework...  
   https://www.youtube.com/watch?v=Y8v9EdmDwck

---

## Intro
vibe coding all the rage these days but occasionally also a source of rage
because the fact of the matter is this You don't know what you don't know
Meaning if you aren't a trained software engineer with a decade or more of experience you've probably got some gaps
in your understanding of things So in this video I thought I'd put together a list of 21 tips that help you take one
step or 21 steps closer to ultimate vibe
coding glory Meaning if you stick through to the end you'll be that much closer to the amazing vibe sass of your
dreams So if you're already a subscriber welcome back If you're new to the channel my name is Sean I try to make AI
and vibe coding easier and simpler and more effective for people like you and me And I draw my experience running
actual businesses that use this stuff to do that So in this video we're going to go through my 21 tips talk about what
each one is and why I think it's important for you to know So this is going to be great for you whether you
are a beginner or even if you're more experienced and just love to learn and
are wondering if there might be something in this list that you didn't know yet I say it a lot on this channel but when a technical skill starts to
become a commodity meaning everyone can do it everyone has access to it you have
to ask yourself what will separate you And understanding what you are doing is
what will separate you and it will become a premium that people will pay for And so my goal for this video is
that at least one of these tips actually helps you improve your process so that you can ride off into the sunset on your
SAS unicorn And so last thing throughout this video I may reference or show you different prompts or multi-step
processes that I use all of which you can grab uh for free inside of my school community down below in the comments So

#### Tip #1
tip number one using widely documented tech stacks Now this is a tip you hear a
lot but it is worth repeating LLMs like Claude are trained on specific code
examples So when you use a widely documented technology or tech stack you're already at an advantage because
odds are someone has already encountered the problems you are running into and have already documented solutions to
those problems which means the AI is a lot less likely to hallucinate solutions that don't actually work This is
actually a big reason why I believe that traditional software developers and engineers will always be needed because
someone's got to build the initial solutions that the AI then becomes trained on that we all then get to go in
and use Someone needs to do that So if you want less headaches and a faster time to having up and running apps use a
stack that people already know and love Tip number two planning extensively

#### Tip #2
ahead of time I personally use a four-step planning process before I even write a line of code Here's why this is
important LLMs are not that good at architecting complex solutions while
also implementing the code at the same time At the end of the day they are limited by how much context they can
handle So really good at solving narrowly defined problems So you want to
really spend 60 to 70% of your time in the development process in the planning
phase And this is how real world software development actually works Meaning what tech stack are you going to
use where in the codebase will you actually use it what gaps in your understanding of what it actually takes
to build this project might there be that you're not aware of yet what are the main requirements of each of those
features like what needs to be in place so that you can look at it and say "Yeah hey this thing actually works the way I
intended it to This is awesome What are those lists of requirements?" Once you have that first step complete you need
to move on to the second stage of that planning process where we're building out robust feature documentation What
are the API endpoints what are the payloads they accept what does the database schema look like what is the
logic of the different components that use those different endpoints what are the complete user stories from A to Z
how do they actually interact with this thing what is it meant to do how is it meant to maintain its state after you've
done all of that you can move on to steps three and four where we start designing and then doing detailed
granular task planning Again full guides and all that stuff inside of the free school group if you want it But the
reason that step is critical is because we don't start that process until the entire app is really welldefined down to
like very small details because once we've done that the actual writing of
the code becomes a lot easier Tip number three use your context wisely Inside of

#### Tip #3
most AI powered development tools you have these little tiny at symbols that
say something like add context And what these allow you to do is they allow you to pass context into the prompt And so
this is critical because LLMs have maximums on how much context they can
process at any given point in time If I tried to pass for example my entire code base with every request it would get way
out of control and it would miss all of the detail that I'm looking for And so you want to control what level of detail
you're passing in every time you ask it to do something And so this does two things Number one you make sure that it
actually has the information it needs in order to answer the question or answer the prompt Number two you're making sure
that it's using all of that processing power that it has to solve a very
specific problem with all of the information that it needs to solve that problem So certain IDs try to do this
for you automatically like windsurf or cursor When you come in here and you type something out like update my app to
do XYZ it is going to go through and it's going to try to determine what the
context is that it needs in order to solve that problem But at the end of the day you know best what that is So you
should come in and actually add that context If I was in this project and I knew that inside of this component
directory are where all of my screens that I've designed live well then I want
to make sure that I am passing this folder in when I make a request that has
to do with these components and how they function and how they interact with each other because now it doesn't need to go
searching and it's not going to miss things that should be there So you want to always be conscious of what is that
context behind the prompt Especially if you start seeing your responses degrading in quality you want to ask
yourself if you are bogging down the context So tip number four commit
## Tip #4
between conversations One of the biggest casualties of vibe coding is that the practice of committing changes is kind
of dying off with beginners Committing changes is pretty simple to do And what it does is it creates a snapshot of your
code Meaning if anything were to ever break you can just roll back to a point
in time where things were actually working It also means that you can work on different features at the same time
and then merge them together as they are ready So my tip here is this Get in the
habit of at least committing your changes between conversations And if you don't really know how to do that you can
come through and you can ask your tool And so there we go We have a
command that was generated for us by the system So again get in the habit of doing that between conversations because
for most vibe coders a conversation coming to an end is like a natural break
point where you would want to commit your changes anyway Right if you're like me when you're done with a new feature
or changes that you made to an existing feature you move to a new conversation So it's a natural point to make that
happen That way if you ignore tips 9 18 and 21 you can at least revert back to a
version of your app that was actually functioning Tip number five commit
## Tip #5
solutions to the system memory Nothing is worse than struggling through the
same problem twice You bash your head against the wall for hours and hours and hours trying to fix some problem that
seemed like it was above your expertise level And finally you break through and create a solution that works And then
tomorrow when you're working on a new feature you run into the exact same bug but now you can't solve the problem the
same way and you are back aboard the struggle bus And so one way we can overcome that is by using memory Most AI
powered idees natively support some sort of memory system or they at least
support MCP servers that are memory servers Meaning anytime you come up with a solution to a a significant problem
which could be as simple as app styling or how you like to debug certain things
you commit it to memory and then those memories persist across the project or
even across multiple projects Meaning if you're using those similar widely
documented text stacks in each of your projects you're going to spend a lot less time reinventing the wheel Tip
## Tip #6
number six ask the system for multiple perspectives on your problem Sometimes
you ask cursor or windurf or sealine or or ro to answer your problem or fix your
problem and it doesn't get it exactly right or maybe it just is still broken What I like to do in these situations
when something seems like it's more complicated than I would like for it to be is that I ask the system to give me
three different approaches to solving that problem and explain why the approach is valid and why it might not
be valid Now I am not a large language model engineer but it seems to help
force the system to really think about the validity of a solution before it recommends it to you I'll give you a
concrete example I was having a hard time recently in a React Native project getting it to properly compress the
audio and send it to my backend and it kept giving me the same attempted
solutions to the problem which kept failing Simply asking the system to give
me three different approaches that might explain why it was failing and what I
should do about it It immediately gave me a solution that actually worked And
bonus points if you have it actually rate on a scale of 1 to 10 why it thinks this is the likely solution to the
problem So when in doubt ask it to consider multiple approaches Tip number seven evaluate your outputs against a
## Tip #7
standard When you think about like AI agents a common pattern that they have
are evaluator optimizers meaning you get an output and you ask a different agent
to evaluate that output and give you critiques on it It then sends that to a
different system the optimizer that fixes the problem and sends it back to the evaluator And that loop continues
until you have a quality output And so this is actually a surprisingly useful method that we can use when we're vibe
coding For example let's say we give our app a style guide to use but it's still producing shitty ugly components for us
We could ask the system to evaluate that output against the style guide and against our aesthetic standards Or maybe
it builds us an authentication system for our app and we want to make sure that authentication system actually
follows best practices in the security space We could ask the system to
evaluate it against known best practices and vulnerabilities Bonus points you can
use an MCP server like Perplexity or XAI Go out and search the web for what those
current up-to-date best practices actually are Evaluator optimizer workflows are great ways to refactor
your code make them better and get better quality outputs over time Tip
## Tip #8
number eight model selection Fact of the matter is certain families of models are
better at coding than others For example Claude 3.7 sonnet thinking is widely
considered to be one of the best LLMs for coding though some of Google's
thinking models are starting to get a lot of attention recently Or maybe you prefer something else entirely like
open- source models only Well swapping between these models intelligently can
often help get a better solution than any of them could separately A an app
that's actually a really good example of this concept is Manis the general AI
assistant app that people are kind of going crazy about It doesn't use just one model It combines different models
to handle different tasks in different orders in order to arrive at an ideal outcome I use Clawude 3.7 almost
exclusively for my planning and architecting but if I run into a bug that I just seem to hit time and time
and time again and Claude isn't figuring it out I will switch to other models to help break through some of those
barriers Kind of think of it like pitting them against each other Tip number nine project rules One of the big
## Tip #9
unsung heroes of these AI coding tools are the project rules Project rules
allow you to create safeguards and guidelines for how your app gets
developed They get passed as context to the LLM so that anytime you run a prompt
that matches those rules it gets sent along with the prompt you give to Claude
or Google or whatever tool you're using So at the very least I recommend having a front-end rule set a back-end rule set
and a style guide rule set Now there's a really awesome tool called cursor
Directory that is a giant repository of different rules that you can go and check out based on what your project
actually is And if you want to get fancy you could break those down even further
database schema rule sets general coding best practice rule sets performance
optimization rule sets state management rule sets the sky's is the limit You can break that down as much as makes sense
for you So project rules will help create serious consistency across and
within projects and it will help make sure you're implementing best practices
## Tip # 10
more often Tip number 10 potentially my favorite tip of them all task planning
So following on that whole concept of the four-step planning process that I mentioned earlier task planning is the
last step Now some idees like Rue Code for example kind of support this type of
stuff out of the box but I've been really loving this open-source tool called Claude Taskmaster which can take
a very large project right the output of stages 1 two and three in our planning
process and it can turn it into a granular stepbystep very detailed task list So
whatever tool you choose task planning is an absolute must right if you were to
think of what is the strength of a tool like Replet or Lovable or Vzero or all of those other kind of hands-off tools
it's that they do that detailed task planning for you and you just don't see it it's kind of obfiscated under the
hood So why is this important it's because it connects your overall project architecture meaning the specific way
that we just spent all this time planning the tech stack and how it's going to all connect together to the actual line by line coding that is about
to take place We make sure it is all cohesive and works with one another One
of the things that's awesome about Clawude Taskmaster is it will actually recursively go back and update its
requirements if it just implemented code that is going to impact something else
And so this makes it a lot easier to develop your code over days or weeks because you can keep track of exactly
where you are what you've done already and what you need to do next Not to mention it keeps you from building the
same thing twice in different pieces of your codebase which wastes time which
wastes money and which creates a lot of frustration when you get into debugging things and the LLM is auto selecting the
wrong context because you didn't realize that you created a file that does the same thing twice Tip number 11 design
## Tip #11
first approach One of the biggest changes that I made to my vibe coding process over the last few months is to
design my screens and the different states of those screens before I start
coding features Meaning I want to think through first how is a user going to
experience this app What does it look like to them how should screens change
depending on what they're doing and the state of what they're doing what are the different types of interactions they can
have with each screen what happens when it's a blank state what happens when there's an error what happens when
there's a success what happens when a user takes a positive action that we want them to take for the first time how
do animations impact the overall experience we want to start thinking
through these things for each individual feature before we start building the feature because you don't want to go and
build something and now you realize that based on what you want to do next now you need to go reverse out of decisions
you made and so this is how it works in like actual SAS companies A product designer develops design systems and
specific screens and specific state indications And then a developer
implements those systems and screens and state indications And so this makes it a lot better for us because then when we
get down to writing code it's just a matter of implementing this very
wellthoughtout thing Now that can still take time and there can still be struggles on that path but at least it
is very clear what we're working through and why And so again I've got an entire
video of that series of prompts and how they chain together and all of that stuff inside of the free course that you
can access Tip number 12 pick a development tool that actually meets you
## Tip #12
where you are at So an IDE is an integrated development environment Do you think of tools like Windsurf or VS
Code or Cursor they are idees Ever since I started creating videos about idees a
few weeks back it's like I opened up a can of worms that I was not expecting
Cursor Windsurf Augment Seaine Rue Code everybody's got their favorite flavor
and they will tell you how they feel about it So RIP the comment section
Everyone's got their thing and I do really think that that's cool The world becomes a better place when smart people
compete to make things better My advice is to pick a tool that makes sense for
you and your experience level the context of your life your budget and
again what makes sense for you Don't feel like you need to use a specific
tool because you see a influencer that you follow using that tool because there
might be something about their background that makes that tool better for them but does not make it better for
you For example if you're super new you want to really start learning to code you're not like super experienced with
it and you're also not super flush with cash Windsurfer Cursor probably a great
option If you're a little bit more experienced with things and maybe you're not as like concerned about the
immediate like resource management of how much cost one of those tools might actually have for you but you want like
really robust context limits on on the stuff you're doing Rue Code or Celine might be a better option for you I am
personally a brand loyal type of guy in all things I do in my life When I find a good company that builds something cool
that I enjoy using I use a lot of their for a very long time And so if you're the same way pick a tool that you
vibe with pun intended and just remove that burden of perpetually trying to
think about that there might be another tool that's actually better for you right now Because to be honest it's a
waste of time Tip number 13 create custom modes for custom use cases One of
## Tip #13
the things that I really love about a lot of these tools is that they have custom modes Meaning you can have a
specific flavor for different tasks So for example inside of Rue Code you could
have a debugging mode that's trained on your ideal method for solving bugs where
maybe you can ask it to give you three different solutions to a problem Shout out to tip number six We see you Or
maybe you have an architect prompt that's trained on your ideal method for brainstorming a broader feature Point
being you can take these frequently used system prompts that you tend to use in
your day-to-day workflow and we can codify them into instructions that we use again and again and again And so one
of the things that I actually really loved about Rue Code is that they have a pretty extensive custom mode system that
are actually pretty highly customizable and and they're built right into it So you could come through here and change
the RO definition or change the instructions that it uses to architect a
solution So this one is a major workflow win for faster development and more
predictable success Tip number 14 always configure upto-date documentation This
## Tip #14
space changes so quickly that if you are not using up-to-date docs you are going to have a bad time Luckily for us
there's three pretty solid ways that we can make sure we have up-to-date documentation So number one uh Cursor
and Windsurf have a direct option for indexing docs All you need to do is come in here and select add new doc And then
you type in the URL to the documentation and it goes So it's going to move
through those pages and it's going to index them And now if you think that the documentation has updated all you need
to do is come in and hit this reindex option and it is going to go through and
index everything from their documentation So for example with this magic UI 103 pages have been indexed and
can be used Number two you could just manually scrape those docs And then what you do you put them in a folder in your
project directory And then when you want to use that tool in your coding workflows you can just go to add
context and choose the folder that has all of that documentation in it So if
this was superbase for example we could provide all of the superbase docs and then we could say go build our
authentication system and it's going to go out and it's going to do it with the context of those docs And so last but
not least you could use an MCP server like Context 7 to pull up-to-date docs
directly from their database and inject them into your project Whichever you pick I recommend updating that every
time there's been a change or if you just haven't been coding for a while and you want to make sure you don't know if there was a change and you just want to
make sure it's up tod date because wasting time and resources vibing away on outof-date documentation or SDKs or
APIs is a huge pain in the ass And let's face it most people don't like to sit
around bashing their head in frustration into their keyboards Tip 15 add early
## Tip #15
returns and logging when you're debugging So a huge pro tip when you are debugging code or building functions is
to ask the system to add in early returns and robust console logging LLMs
are actually surprisingly good at solving a problem When you give it the logs of what is happening at each
execution stage in order of your code it can hone in pretty quickly on the things
that are going wrong and what it needs to do to actually solve that And bonus
points if you're using one of those custom modes you can actually add that in as part of your custom mode to add
robust console locking as it begins to debug a problem And so that's going to save you a ton of time and help you
avoid a lot of frustration Tip number 16 using checkpoint restores I still hold
## Tip #16
that one of the greatest contributions to the vibe coding universe is
checkpoint restoration inside of a chat Inside of cursor and windsurf we have these options to restore to a checkpoint
And so this is kind of like the poor man's version of a code commit or
reverting back to a previous commit after something breaks but it works well when you're vibing So if you run into
any problems or something breaks unexpectedly you can easily revert your code back to the way it was before you
made that change And so that gives you time to number one commit the change for real this time And number two think
about how you might prompt it differently to avoid that problem happening again because nothing is worse
than having a perfectly wellfunctioning app fall apart at the seams because you
decided to give one or two overly ambitious prompts that imploded on you especially if you have no clue in the
world how to get it back Tip number 17 understand it before you accept it I
## Tip #17
would honestly recommend getting into the habit of actually reading the code
that AI is generating for you And if you are feeling especially daring you could ask it to explain how the code works or
what certain pieces maybe that strike your interest actually mean One thing that you will find as you get more
experience with the coding side of vibe coding is that you can often spot a
problem before the language model does because for all its greatness sometimes
these things just miss like plainly obvious problems And when you tell it that it says "hm yeah that was a really
good point You're right I should do it that way That is what's creating this problem I should have seen that." So
getting to a point where you're really actually understanding the things that are going into your project will really
help you avoid a lot of those situations in the future and just overall get better at this Meaning spending less
money on needless requests and honestly being able to solve more difficult
problems because you actually understand what is going on Tip number 18 MVP it
## Tip #18
then enhance it Yes the proverbial MVP If there's one
tip on this list that I should honestly listen to more of myself it is this one
To actually build an MVP first especially if you follow a robust vibe
planning system like the ones I've alluded to a few times in this video you often get these really robust long-term
development plans But it's really important to stop and think what is the
simplest version of this thing that I could build that someone would actually find valuable you need to avoid the
temptation to build the entire thing at once I once spent a year and a half with
a business partner building an entire application that we could have launched
to users in pieces only to find out that the users didn't even use 75% of the
features we built You want to avoid that situation because you don't want your
lifechanging project to end up in the dumpster pile of half-completed projects
because it got too unwieldy and wild for you to deal with And that can happen
pretty fast when you're letting AI whip up a bunch of code that you're committing into the system without even
reading it or attempting to understand what it even does So again take the time to think what is the simplest version of
this thing that would actually be valuable Build that first and then hook
all your other cool into it Tip number 19 clearly identify your tech in
## Tip #19
your project rules Another annoyance with some of these AI coding workflows is when the LLM decides to randomly
inject redundant libraries or tools into your project in order to solve a problem
doesn't feel like finding the right icon with React Lucid Why not just install the feather icons library and start
picking icons from there so this is especially problematic when you start getting into tech that you don't really
understand that well You start off with you know one OM that you're using with
Superbase and unbeknownst to you halfway through the project it starts using a different one And so you want to avoid
that situation like the plague And the best way to do that is to use project rules where you're clearly specifying
what your tech stack is and what those pieces are used for Tip number 20 security checks On the topic of
## Tip #20
evaluator optimizer workflows that we talked about earlier I recommend spending time to run security checks
Again especially if your project rules aren't configured with security in mind
you might do something stupid like sending your authentication tokens through front-end requests and then next
thing you know your app is hacked and your users hate you And so one nice way to avoid this is having a process or a
workflow that you can run to regularly evaluate critical pieces of your codebase against known security best
practices vulnerabilities and risks Because nothing would be worse than busting your ass to build some cool app
that you really love get users in it and then lose all trust because of something
that you could have taken time to avoid Last but not least tip number 21 creating new conversations as needed So
## Tip #21
on the topic of context a lot of these AI powered idees send your entire
conversation as context to the language model So this actually becomes painfully
obvious if you're using a tool like R code or Cine One second you're at 10,000
tokens used and then you ask one simple question and it jumps to 25,000 tokens
and then 46,000 tokens It's because these tools are often passing the entire conversation as context Something that I
find super useful is finding natural break points to just create a new conversation As in if it's not actually
necessary to have the entire context of what you just talked about in the prompt that you're about to ask next you should
probably just move to a new conversation altogether And so this will also help you become more deliberate and concise
with how you're developing things and how you choose to move from one task to the next because swapping to a new
conversation kind of implies that you've reached the end of a certain chain of thought You should commit that change
and now move on See that coming full circle back to the commit often So
that's it guys You know this video was actually valuable for me and I'm sure it was for you too If you want more content
like this subscribe to the channel And again if you want all of those prompts that I mentioned throughout the video
which are entirely free you can get access to them in the school group below
this video But that is it for this one and I will see you in the next video

